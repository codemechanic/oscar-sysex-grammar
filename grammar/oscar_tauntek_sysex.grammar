<?xml version="1.0" encoding="UTF-8"?>
<ufwb version="1.17">
    <grammar name="OSCar Tauntek MIDI Sysex" start="id:6" author="Ben Allen" email="codemechanic@gmail.com" fileextension=".syx">
        <description>Grammar for the OSCar Tauntek MIDI System Exclusive format</description>
        <scripts>
            <script name="OSCar Exclusive Data Format" type="DataType" id="702">
                <source language="Python">
# OSCar Exclusive Data Format
#
# 2 MIDI bytes contain one byte of data
# first byte contains low 4 bit nibble
# second byte contains high 4 bit nibble
#
# 0                8               16
# +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
# |0|0|0|0|l|l|l|l| |0|0|0|0|h|h|h|h|
# +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
# \______/ \______/ \______/ \______/
#  4 zero   4 low    4 zero   4 high 


def parseByteRange(element, byteView, bitPos, bitLength, results):
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

		initialBitHigh = byteView.readUnsignedIntBits(bitPos+8, 1, ENDIAN_BIG)

		if (initialBitHigh == 0):

			# combine high and low nibbles from two bytes into one byte
			low = byteView.readUnsignedIntBits(bitPos+4, 4, ENDIAN_BIG)
			high = byteView.readUnsignedIntBits(bitPos+12, 4, ENDIAN_BIG)
			result = (high &lt;&lt; 4) | low;

			# return value to results
			value = Value()
			value.setString(str(result))
			results.addElement(element, 2, 0, value)
			processedBytes = 2

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	if (bitLength &lt; 16):
		print &quot;Not enough space for OSCar Exclusive Data Format, 16 bits needed&quot;

	# get number edited by user
	number = value.getUnsigned()
	high, low = number &gt;&gt; 4, number &amp; 0x0F

	# verbose flag
	verbose = False

	# verbose info
	if verbose:
		print(&quot;Input value: &quot; + str(number))
		print(&quot;byteArray length: &quot; + str(byteArray.getLength()))
		print(&quot;bitPos: &quot; + str(bitPos))
		print(&quot;bitLength: &quot; + str(bitLength))

		# number in hex
		numHex = str.format('0x{:02X}', int(str(number), 16))
		print(&quot;Input value hex: &quot; + str(numHex))

		# number in binary
		numBinary = '{0:08b}'.format(number)
		print(&quot;Input value binary: &quot; + str(numBinary))
		
		# number high and low nibbles
		print(&quot;Input value binary (low nibble): &quot; + str('{0:04b}'.format(low)))
		print(&quot;Input value binary (high nibble): &quot; + str('{0:04b}'.format(high)))

	if (number &lt; 256):
		byteArray.writeUnsignedIntBits(low, bitPos, 8, ENDIAN_BIG)
		byteArray.writeUnsignedIntBits(high, bitPos+8, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-255). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Arpeggiator Mode Byte" type="DataType" id="170">
                <source language="Python">
# OSCar Arpeggiator Modes Byte
#
# (Positive Logic)
#
# Bit 0 down direction
# Bit 1 up direction (bits 0 and 1 enabled gives alternate up/down)
# Bit 2 deleting (hands-on) mode
# Bit 3 memory mode (bits 2 and 3 are mutually exclusive)
#
# 0               8
# +-+-+-+-+-+-+-+-+
# |0|0|0|0|3|2|1|0|
# +-+-+-+-+-+-+-+-+
# \______/ | | | |
#  4 zero  3 2 1 0

from enum import Enum
arpMemLabel = Enum('MemoryMode', 'disabled, enabled', start=0)
arpDelLabel = Enum('DeleteMode', 'disabled, enabled', start=0)
arpUpLabel = Enum('UpDirection', 'disabled, enabled', start=0)
arpDownLabel = Enum('DownDirection', 'disabled, enabled', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			arpMem = byteView.readUnsignedIntBits(bitPos+4, 1, ENDIAN_BIG)
			arpDel = byteView.readUnsignedIntBits(bitPos+5, 1, ENDIAN_BIG)
			arpUp = byteView.readUnsignedIntBits(bitPos+6, 1, ENDIAN_BIG)
			arpDown = byteView.readUnsignedIntBits(bitPos+7, 1, ENDIAN_BIG)

			# set values
			padding = Value()
			arpMemResult = Value()
			arpDelResult = Value()
			arpUpResult = Value()
			arpDownResult = Value()

			# set value strings
			padding.setString(&quot;padding: 0000&quot;)
			arpMemResult.setString(str(arpMem) + &quot;: memory mode &quot; + str(arpMemLabel(arpMem).name))
			arpDelResult.setString(str(arpDel) + &quot;: delete mode &quot; + str(arpDelLabel(arpDel).name))
			arpUpResult.setString(str(arpUp) + &quot;: up direction &quot; + str(arpUpLabel(arpUp).name))
			arpDownResult.setString(str(arpDown) + &quot;: down direction &quot; + str(arpDownLabel(arpDown).name))

			# add values to results
			results.addElementBits(element, 4, 0, padding)
			results.addElementBits(element, 1, 0, arpMemResult)
			results.addElementBits(element, 1, 0, arpDelResult)
			results.addElementBits(element, 1, 0, arpUpResult)
			results.addElementBits(element, 1, 0, arpDownResult)

			processedBytes = 1

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; 2):
		byteArray.writeUnsignedIntBits(number, bitPos, 1, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-1). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Glide Type Byte" type="DataType" id="183">
                <source language="Python">
# OSCar Glide Type Byte
#
# Glide Type Labels 0-5

from enum import Enum
valueLabels = Enum('GlideType', 'Normal, Auto, Glissando, Normal-Fixed, Auto-Fixed, Glissando-Fixed', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Waveform 1 Byte" type="DataType" id="185">
                <source language="Python">
# OSCar Waveform 1 Byte
#
# Waveform 1 Labels 0-15

from enum import Enum
valueLabels = Enum('Waveform1', 'Triangle, Sawtooth, Square, Pulse, PWM, Off, Preset-Waveform[-3], Preset-Waveform[-4], Preset-Waveform[-5], Preset-Waveform[-6], Preset-Waveform[-7], Built-Waveform[-8], Built-Waveform[-9], Built-Waveform[-10], Built-Waveform[-11], Built-Waveform[-12]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+4, 4, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Waveform 2 Byte" type="DataType" id="187">
                <source language="Python">
# OSCar Waveform 2 Byte
#
# Waveform 2 Labels 0-15

from enum import Enum
valueLabels = Enum('Waveform2', 'Triangle, Sawtooth, Square, Pulse, PWM, OSC1, Preset-Waveform[-3], Preset-Waveform[-4], Preset-Waveform[-5], Preset-Waveform[-6], Preset-Waveform[-7], Built-Waveform[-8], Built-Waveform[-9], Built-Waveform[-10], Built-Waveform[-11], Built-Waveform[-12]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+4, 4, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Octave Shift Byte" type="DataType" id="188">
                <source language="Python">
# OSCar Octave Shift Byte
#
# Octave Shift Labels 0-4

from enum import Enum
valueLabels = Enum('OctaveShift', 'Octave[+2], Octave[+1], Center, Octave[-1], Octave[-2]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Octave Setting Byte" type="DataType" id="191">
                <source language="Python">
# OSCar Octave Setting Byte
#
# Octave Setting Labels 0-4

from enum import Enum
valueLabels = Enum('OctaveSetting', 'Octave[+2], Octave[+1], Center, Octave[-1], Octave[-2]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Tauntek Function Byte" type="DataType" id="192">
                <source language="Python">
# OSCar Function Byte
#
# No LFO to OSC 1 Labels 0-1
# Function Labels 0-5

from enum import Enum
functionLabels = Enum('Function', 'Normal, Arpeggiator, Duophonic, Normal-Hold, Arpeggiator-Hold, Duophonic-Hold', start=0)
tauntekLabels = Enum('noLFOtoOSC1', 'disabled, enabled', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			tauntek = byteView.readUnsignedIntBits(bitPos+4, 1, ENDIAN_BIG)
			function = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (function &lt; len(functionLabels)) and (tauntek &lt; len(tauntekLabels)):

				# set values
				padding = Value()
				tauntekResult = Value()
				functionResult = Value()

				# set value strings
				padding.setString(&quot;padding: 0000&quot;)
				tauntekResult.setString(str(tauntek) + &quot;: No LFO to OSC 1 &quot; + str(tauntekLabels(tauntek).name))
				functionResult.setString(str(function) + &quot;: &quot; + str(functionLabels(function).name))

				# add values to results
				results.addElementBits(element, 4, 0, padding)
				results.addElementBits(element, 1, 0, tauntekResult)
				results.addElementBits(element, 3, 0, functionResult)

				processedBytes = 1
			else:
				print(&quot;Value out of range&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Tauntek LFO Waveform" type="DataType" id="193">
                <source language="Python">
# OSCar LFO Waveform Byte
#
# LFO Waveform Labels 0-5

from enum import Enum
valueLabels = Enum('LFOWaveform', 'Triangle, Sawtooth, Square, Filter-Envelope, Keyboard, Random', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Tauntek Filter Type" type="DataType" id="194">
                <source language="Python">
# OSCar Filter Type Byte
#
# Filter Labels 0-5

from enum import Enum
valueLabels = Enum('FilterType', 'Lowpass, Bandpass, Highpass, Lowpass-No-Track, Bandpass-No-Track, Highpass-No-Track', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Tauntek Trigger Type" type="DataType" id="195">
                <source language="Python">
# OSCar Trigger Type Byte
#
# Filter Labels 0-5

from enum import Enum
valueLabels = Enum('TriggerType', 'Single, Multiple, Repeat-1, Repeat-2, Repeat-1+2, External', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+5, 3, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar Tuning Semitone" type="DataType" id="196">
                <source language="Python">
# OSCar Tuning Semitone Byte
#
# Tuning Semitone Labels 0-14

from enum import Enum
valueLabels = Enum('TuningSemitone', 'Triangle, Sawtooth, Square, Pulse, PWM, OSC1, Preset-Waveform[-3], Preset-Waveform[-4], Preset-Waveform[-5], Preset-Waveform[-6], Preset-Waveform[-7], Built-Waveform[-8], Built-Waveform[-9], Built-Waveform[-10], Built-Waveform[-11], Built-Waveform[-12]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+4, 4, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
            <script name="OSCar OSC 2 Semitone Byte" type="DataType" id="198">
                <source language="Python">
# OSCar OSC 2 Semitone Byte
#
# OSC 2 Semitone Labels 0-14

from enum import Enum
valueLabels = Enum('OSC2Semitone', 'Triangle, Sawtooth, Square, Pulse, PWM, OSC1, Preset-Waveform[-3], Preset-Waveform[-4], Preset-Waveform[-5], Preset-Waveform[-6], Preset-Waveform[-7], Built-Waveform[-8], Built-Waveform[-9], Built-Waveform[-10], Built-Waveform[-11], Built-Waveform[-12]', start=0)

def parseByteRange(element, byteView, bitPos, bitLength, results):
	# this method parses data starting at bitPos, bitLength bits are remaining
	&quot;&quot;&quot;parseByteRange method&quot;&quot;&quot;

	processedBytes = 0
	initialBitLow = byteView.readUnsignedIntBits(bitPos, 1, ENDIAN_BIG)

	if (initialBitLow == 0):

			# read bits
			result = byteView.readUnsignedIntBits(bitPos+4, 4, ENDIAN_BIG)

			# return value to results
			if (result &lt; len(valueLabels)):
				value = Value()
				value.setString(str(result) + &quot;: &quot; + str(valueLabels(result).name))
				results.addElement(element, 1, 0, value)
				processedBytes = 1
			else:
				print(&quot;Value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;)&quot;)

	return processedBytes

def fillByteRange(value, byteArray, bitPos, bitLength):
	# this method translates edited values back to the file
	&quot;&quot;&quot;fillByteRange method&quot;&quot;&quot;

	# get number edited by user
	number = value.getUnsigned()

	if (number &lt; len(valueLabels)):
		byteArray.writeUnsignedIntBits(number, bitPos, 8, ENDIAN_BIG)
	else:
		print(&quot;Input value out of range (0-&quot; + str(len(valueLabels)-1) + &quot;). Value not updated.&quot;)
                </source>
            </script>
        </scripts>
        <structure name="Start of System Exclusive" id="7" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <number name="Byte" mustmatch="yes" id="8" type="integer" length="1" display="hex">
                <fixedvalues>
                    <fixedvalue name="SOX" value="0xF0"/>
                </fixedvalues>
            </number>
        </structure>
        <structure name="Single Byte ID" id="10" length="1" alignment="0" repeatmin="0" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <binary name="First bit" mustmatch="yes" id="11" length="1" lengthunit="bit">
                <fixedvalues>
                    <fixedvalue name="Zero" value="00"/>
                </fixedvalues>
            </binary>
            <number name="Manufacturer" id="12" type="integer" length="7" lengthunit="bit" display="hex">
                <fixedvalues>
                    <fixedvalue name="Sequential Circuits" value="0x1"/>
                    <fixedvalue name="Moog" value="0x4"/>
                    <fixedvalue name="Passport Designs" value="0x5"/>
                    <fixedvalue name="Lexicon" value="0x6"/>
                    <fixedvalue name="Kurzweil" value="0x7"/>
                    <fixedvalue name="Fender" value="0x8"/>
                    <fixedvalue name="AKG Acoustics" value="0xA"/>
                    <fixedvalue name="Ensoniq" value="0xF"/>
                    <fixedvalue name="Oberheim" value="0x10"/>
                    <fixedvalue name="Apple" value="0x11"/>
                    <fixedvalue name="Digidesign" value="0x13"/>
                    <fixedvalue name="Emu" value="0x18"/>
                    <fixedvalue name="ART" value="0x1A"/>
                    <fixedvalue name="Eventide" value="0x1C"/>
                    <fixedvalue name="Synthaxe" value="0x22"/>
                    <fixedvalue name="Hohner" value="0x24"/>
                    <fixedvalue name="PPG" value="0x29"/>
                    <fixedvalue name="SSL" value="0x2B"/>
                    <fixedvalue name="Hinton Instruments" value="0x2D"/>
                    <fixedvalue name="Elka / General Music" value="0x2F"/>
                    <fixedvalue name="Dynacord" value="0x30"/>
                    <fixedvalue name="Clavia (Nord)" value="0x33"/>
                    <fixedvalue name="Cheetah" value="0x36"/>
                    <fixedvalue name="Waldorf Electronics Gmbh" value="0x3E"/>
                    <fixedvalue name="Kawai" value="0x40"/>
                    <fixedvalue name="Roland" value="0x41"/>
                    <fixedvalue name="Korg" value="0x42"/>
                    <fixedvalue name="Yamaha" value="0x43"/>
                    <fixedvalue name="Casio" value="0x44"/>
                    <fixedvalue name="Akai" value="0x47"/>
                    <fixedvalue name="JVC" value="0x48"/>
                    <fixedvalue name="Sony" value="0x4C"/>
                    <fixedvalue name="Teac Corporation" value="0x4E"/>
                    <fixedvalue name="Fostex" value="0x51"/>
                    <fixedvalue name="Zoom" value="0x52"/>
                </fixedvalues>
            </number>
        </structure>
        <structure name="Multi Byte ID" id="14" length="3" alignment="0" repeatmin="0" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <number name="First Byte" mustmatch="yes" id="15" length="1" display="hex">
                <fixedvalues>
                    <fixedvalue name="Extended" value="0x0"/>
                </fixedvalues>
            </number>
            <number name="Manufacturer" id="16" type="integer" length="2" display="hex">
                <fixedvalues>
                    <fixedvalue name="Digital Music Corporation" value="0x7"/>
                    <fixedvalue name="New England Digital" value="0x9"/>
                    <fixedvalue name="Alesis" value="0xE"/>
                    <fixedvalue name="KAT" value="0x15"/>
                    <fixedvalue name="Opcode" value="0x16"/>
                    <fixedvalue name="Allen &amp; Heath Brenell" value="0x1A"/>
                    <fixedvalue name="Peavey Electronics" value="0x1B"/>
                    <fixedvalue name="360 Systems" value="0x1C"/>
                    <fixedvalue name="Zeta Systems" value="0x1F"/>
                    <fixedvalue name="Axxes" value="0x20"/>
                    <fixedvalue name="Mark Of The Unicorn (MOTU)" value="0x3B"/>
                    <fixedvalue name="Studio Electronics" value="0x4D"/>
                    <fixedvalue name="MIDI Solutions Inc" value="0x50"/>
                    <fixedvalue name="M-Audio (Midiman)" value="0x105"/>
                    <fixedvalue name="PreSonus" value="0x106"/>
                    <fixedvalue name="Radikal Technologies" value="0x136"/>
                    <fixedvalue name="Roger Linn Design" value="0x137"/>
                    <fixedvalue name="Plogue Art et Technologie" value="0x15A"/>
                    <fixedvalue name="Livid" value="0x161"/>
                    <fixedvalue name="Source Audio LLC" value="0x16C"/>
                    <fixedvalue name="Kilpatrick Audio" value="0x172"/>
                    <fixedvalue name="iConnectivity" value="0x173"/>
                    <fixedvalue name="Intellijel Designs Inc" value="0x214"/>
                    <fixedvalue name="Sensel Inc" value="0x21D"/>
                    <fixedvalue name="Electro-Harmonix" value="0x226"/>
                    <fixedvalue name="Forefront Technology" value="0x2011"/>
                    <fixedvalue name="Kenton Electronics" value="0x2013"/>
                    <fixedvalue name="TC Electronic" value="0x201F"/>
                    <fixedvalue name="Doepfer" value="0x2020"/>
                    <fixedvalue name="Acorn Computer" value="0x2027"/>
                    <fixedvalue name="Focusrite / Novation" value="0x2029"/>
                    <fixedvalue name="Behringer" value="0x2032"/>
                    <fixedvalue name="Access Music Electronics" value="0x2033"/>
                    <fixedvalue name="Elektron" value="0x203C"/>
                    <fixedvalue name="Vermona" value="0x204D"/>
                    <fixedvalue name="Analogue Systems" value="0x2052"/>
                    <fixedvalue name="genoQs Machines GmbH" value="0x2064"/>
                    <fixedvalue name="Elby Designs" value="0x2069"/>
                    <fixedvalue name="Arturia" value="0x206B"/>
                    <fixedvalue name="C-Thru Music" value="0x206D"/>
                    <fixedvalue name="OTO Machines" value="0x2070"/>
                    <fixedvalue name="Teenage Engineering" value="0x2076"/>
                    <fixedvalue name="Mutable Instruments" value="0x2102"/>
                    <fixedvalue name="PreSonus Software Ltd" value="0x2103"/>
                    <fixedvalue name="Modal Electronics" value="0x2107"/>
                    <fixedvalue name="Native Instruments" value="0x2109"/>
                    <fixedvalue name="ROLI Ltd" value="0x2110"/>
                    <fixedvalue name="Rob Papen" value="0x2117"/>
                    <fixedvalue name="IK Multimedia" value="0x211A"/>
                    <fixedvalue name="Modor Music" value="0x211C"/>
                    <fixedvalue name="Ableton" value="0x211D"/>
                    <fixedvalue name="Retrokits" value="0x2123"/>
                    <fixedvalue name="Expressive E" value="0x2126"/>
                    <fixedvalue name="Expert Sleepers" value="0x2127"/>
                    <fixedvalue name="Sonic Potions" value="0x212A"/>
                    <fixedvalue name="Dreadbox P.C." value="0x2135"/>
                    <fixedvalue name="ALM Co (Busy Circuits)" value="0x2138"/>
                    <fixedvalue name="Bitwig GmbH" value="0x2149"/>
                </fixedvalues>
            </number>
        </structure>
        <structure name="Identification Code" id="18" length="0" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <scriptelement name="mapID" id="19">
                <script name="unnamed" type="Generic">
                    <source language="Python">
currentGrammar = currentMapper.getCurrentGrammar()
multiByteID = currentGrammar.getStructureByName(&quot;Multi Byte ID&quot;)
singleByteID = currentGrammar.getStructureByName(&quot;Single Byte ID&quot;)

currentPos = currentMapper.getCurrentOffset()
byteView = currentMapper.getCurrentByteView()
byte = byteView.readByte(currentPos)

if (byte == 0x00):
	currentMapper.mapStructure(multiByteID)
	debugLog(&quot;Multi Byte ID mapped at offset &quot; + str(currentPos))
else:
	currentMapper.mapStructure(singleByteID)
	debugLog(&quot;Single Byte ID mapped at offset &quot; + str(currentPos))
                    </source>
                </script>
            </scriptelement>
        </structure>
        <structure name="Harmonic Table" id="21" length="48" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <custom name="Fundamental" id="22" script="id:702"/>
            <custom name="2nd Harmonic" id="23" script="id:702"/>
            <custom name="3rd Harmonic" id="24" script="id:702"/>
            <custom name="4th Harmonic" id="25" script="id:702"/>
            <custom name="5th Harmonic" id="26" script="id:702"/>
            <custom name="6th Harmonic" id="27" script="id:702"/>
            <custom name="7th Harmonic" id="28" script="id:702"/>
            <custom name="8th Harmonic" id="29" script="id:702"/>
            <custom name="9th Harmonic" id="30" script="id:702"/>
            <custom name="10th Harmonic" id="31" script="id:702"/>
            <custom name="11th Harmonic" id="32" script="id:702"/>
            <custom name="12th Harmonic" id="33" script="id:702"/>
            <custom name="13th Harmonic" id="34" script="id:702"/>
            <custom name="14th Harmonic" id="35" script="id:702"/>
            <custom name="15th Harmonic" id="36" script="id:702"/>
            <custom name="16th Harmonic" id="37" script="id:702"/>
            <custom name="17th Harmonic" id="38" script="id:702"/>
            <custom name="18th Harmonic" id="39" script="id:702"/>
            <custom name="19th Harmonic" id="40" script="id:702"/>
            <custom name="20th Harmonic" id="41" script="id:702"/>
            <custom name="21st Harmonic" id="42" script="id:702"/>
            <custom name="22nd Harmonic" id="43" script="id:702"/>
            <custom name="23rd Harmonic" id="44" script="id:702"/>
            <custom name="24th Harmonic" id="45" script="id:702"/>
        </structure>
        <structure name="Voice Program" id="47" length="64" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <custom name="Filter Drive" id="48" script="id:702"/>
            <custom name="Oscillator Balance" id="49" script="id:702"/>
            <custom name="Noise Balance" id="50" script="id:702"/>
            <custom name="Filter Frequency" id="51" script="id:702"/>
            <custom name="Filter Separation" id="52" script="id:702"/>
            <custom name="Volume Sustain Level" id="53" script="id:702"/>
            <custom name="Bend Amount" id="54" script="id:702"/>
            <custom name="Mod Wheel Pitch Amount" id="55" script="id:702"/>
            <custom name="Mod Wheel Filter Amount" id="56" script="id:702"/>
            <custom name="Pulse Width" id="57" script="id:702"/>
            <custom name="Q (Resonance)" id="58" script="id:702"/>
            <custom name="Filter Sustain Level" id="59" script="id:702"/>
            <custom name="Detune" id="60" script="id:702"/>
            <custom name="Direct Filter Mod Amount" id="61" script="id:702"/>
            <custom name="Envelope Amount to Filter" id="62" script="id:702"/>
            <custom name="Direct Pitch Mod Amount" id="63" script="id:702"/>
            <custom name="Gate Time" id="64" script="id:702"/>
            <custom name="Volume Attack" id="65" script="id:702"/>
            <custom name="Volume Release" id="66" script="id:702"/>
            <custom name="Volume Decay" id="67" script="id:702"/>
            <custom name="Filter Attack" id="68" script="id:702"/>
            <custom name="Filter Release" id="69" script="id:702"/>
            <custom name="Filter Decay" id="70" script="id:702"/>
            <custom name="Glide Rate" id="71" script="id:702"/>
            <custom name="LFO Rate" id="72" script="id:702"/>
            <custom name="Intro Delay Time" id="73" script="id:702"/>
            <custom name="Waveform 1" id="74" script="id:185"/>
            <custom name="Glide Type" id="75" script="id:183"/>
            <custom name="Octave Shift" id="76" script="id:188"/>
            <custom name="Waveform 2" id="77" script="id:187"/>
            <custom name="Function" id="78" script="id:192"/>
            <custom name="LFO Waveform" id="79" script="id:193"/>
            <custom name="Filter Type" id="80" script="id:194"/>
            <custom name="Trigger Type" id="81" script="id:195"/>
            <custom name="Tuning Semitone" id="82" script="id:196"/>
            <custom name="OSC 2 Semitone" id="83" script="id:198"/>
            <custom name="Arpeggiator Mode" id="84" script="id:170"/>
            <custom name="Octave Setting" id="85" script="id:191"/>
        </structure>
        <structure name="OSCar Data" id="87" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <number name="Type" id="88" type="integer" length="1"/>
        </structure>
        <structure name="Waveform Harmonic Data" id="90" extends="id:87">
            <number name="Type" mustmatch="yes" id="91" type="integer">
                <fixedvalues>
                    <fixedvalue name="Waveform Harmonic Data" value="1"/>
                </fixedvalues>
            </number>
            <structref name="Harmonic Table -8" id="92" structure="id:21"/>
            <structref name="Harmonic Table -9" id="93" structure="id:21"/>
            <structref name="Harmonic Table -10" id="94" structure="id:21"/>
            <structref name="Harmonic Table -11" id="95" structure="id:21"/>
            <structref name="Harmonic Table -12" id="96" structure="id:21"/>
        </structure>
        <structure name="Voice Program Data" id="98" extends="id:87">
            <number name="Type" mustmatch="yes" id="99" type="integer">
                <fixedvalues>
                    <fixedvalue name="Voice Program Data" value="2"/>
                </fixedvalues>
            </number>
            <structref name="Voice Program -1" id="100" structure="id:47"/>
            <structref name="Voice Program -2" id="101" structure="id:47"/>
            <structref name="Voice Program -3" id="102" structure="id:47"/>
            <structref name="Voice Program -4" id="103" structure="id:47"/>
            <structref name="Voice Program -5" id="104" structure="id:47"/>
            <structref name="Voice Program -6" id="105" structure="id:47"/>
            <structref name="Voice Program -7" id="106" structure="id:47"/>
            <structref name="Voice Program -8" id="107" structure="id:47"/>
            <structref name="Voice Program -9" id="108" structure="id:47"/>
            <structref name="Voice Program -10" id="109" structure="id:47"/>
            <structref name="Voice Program -11" id="110" structure="id:47"/>
            <structref name="Voice Program -12" id="111" structure="id:47"/>
            <structref name="Voice Program 1" id="112" structure="id:47"/>
            <structref name="Voice Program 2" id="113" structure="id:47"/>
            <structref name="Voice Program 3" id="114" structure="id:47"/>
            <structref name="Voice Program 4" id="115" structure="id:47"/>
            <structref name="Voice Program 5" id="116" structure="id:47"/>
            <structref name="Voice Program 6" id="117" structure="id:47"/>
            <structref name="Voice Program 7" id="118" structure="id:47"/>
            <structref name="Voice Program 8" id="119" structure="id:47"/>
            <structref name="Voice Program 9" id="120" structure="id:47"/>
            <structref name="Voice Program 10" id="121" structure="id:47"/>
            <structref name="Voice Program 11" id="122" structure="id:47"/>
            <structref name="Voice Program 12" id="123" structure="id:47"/>
            <structref name="Voice Program 13" id="124" structure="id:47"/>
            <structref name="Voice Program 14" id="125" structure="id:47"/>
            <structref name="Voice Program 15" id="126" structure="id:47"/>
            <structref name="Voice Program 16" id="127" structure="id:47"/>
            <structref name="Voice Program 17" id="128" structure="id:47"/>
            <structref name="Voice Program 18" id="129" structure="id:47"/>
            <structref name="Voice Program 19" id="130" structure="id:47"/>
            <structref name="Voice Program 20" id="131" structure="id:47"/>
            <structref name="Voice Program 21" id="132" structure="id:47"/>
            <structref name="Voice Program 22" id="133" structure="id:47"/>
            <structref name="Voice Program 23" id="134" structure="id:47"/>
            <structref name="Voice Program 24" id="135" structure="id:47"/>
        </structure>
        <structure name="Sequence Data" id="137" extends="id:87">
            <number name="Type" mustmatch="yes" id="138" type="integer">
                <fixedvalues>
                    <fixedvalue name="Sequence Data" value="3"/>
                </fixedvalues>
            </number>
            <structure name="Length Block" id="139">
                <custom name="Sequence 1 Length" id="140" script="id:702"/>
                <custom name="Sequence 2 Length" id="141" script="id:702"/>
                <custom name="Sequence 3 Length" id="142" script="id:702"/>
                <custom name="Sequence 4 Length" id="143" script="id:702"/>
                <custom name="Sequence 5 Length" id="144" script="id:702"/>
                <custom name="Sequence 6 Length" id="145" script="id:702"/>
                <custom name="Sequence 7 Length" id="146" script="id:702"/>
                <custom name="Sequence 8 Length" id="147" script="id:702"/>
                <custom name="Sequence 9 Length" id="148" script="id:702"/>
                <custom name="Sequence 10 Length" id="149" script="id:702"/>
                <custom name="Sequence 11 Length" id="150" script="id:702"/>
                <custom name="Sequence 12 Length" id="151" script="id:702"/>
                <custom name="Sequence 13 Length" id="152" script="id:702"/>
                <custom name="Sequence 14 Length" id="153" script="id:702"/>
                <custom name="Sequence 15 Length" id="154" script="id:702"/>
                <custom name="Sequence 16 Length" id="155" script="id:702"/>
                <custom name="Sequence 17 Length" id="156" script="id:702"/>
                <custom name="Sequence 18 Length" id="157" script="id:702"/>
                <custom name="Sequence 19 Length" id="158" script="id:702"/>
                <custom name="Sequence 20 Length" id="159" script="id:702"/>
                <custom name="Sequence 21 Length" id="160" script="id:702"/>
                <custom name="Sequence 22 Length" id="161" script="id:702"/>
            </structure>
            <structure name="Data Block" id="163" length="0">
                <custom name="EDF Byte" id="164" repeatmin="22" repeatmax="22"/>
            </structure>
        </structure>
        <structure name="End of System Exclusive" id="167" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <number name="Byte" mustmatch="yes" id="168" type="integer" length="1" display="hex">
                <fixedvalues>
                    <fixedvalue name="EOX" value="0xF7"/>
                </fixedvalues>
            </number>
        </structure>
        <structure name="Chunk" id="170" repeatmax="-1" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <structref name="Start of System Exclusive" id="171" structure="id:7"/>
            <structref name="Identification Code" id="172" structure="id:18"/>
            <structref name="Waveform Harmonic Data" id="173" repeatmin="0" structure="id:90"/>
            <structref name="Voice Program Data" id="174" repeatmin="0" structure="id:98"/>
            <structref name="Sequence Data" id="175" repeatmin="0" structure="id:137"/>
            <structref name="End of System Exclusive" id="176" structure="id:167"/>
        </structure>
        <structure name="MIDI System Exclusive" id="6" encoding="ISO_8859-1:1987" endian="big" signed="no">
            <structref name="Chunk" id="178" repeatmax="-1" structure="id:170"/>
        </structure>
    </grammar>
</ufwb>
